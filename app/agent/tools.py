# packages/agent/crypto_agent/agent/tools.py
from langchain_core.tools import tool
from app.core.models import StrategyConfig, BacktestResult
from app.trading-engine.backtester import run_backtest
from app.trading-engine.features import get_available_features
from app.agent.memory import save_research_note, query_knowledge_base
from pydantic import BaseModel
import json

class RunBacktestInput(BaseModel):
    name: str
    description: str
    features: list[str]
    entry_logic: str
    exit_logic: str
    assets: list[str]
    timeframe: str
    lookback_days: int = 730
    stop_loss_pct: float = 0.03
    take_profit_pct: float = 0.06

@tool("run_backtest", args_schema=RunBacktestInput)
def run_backtest_tool(
    name: str, description: str, features: list[str],
    entry_logic: str, exit_logic: str, assets: list[str],
    timeframe: str, lookback_days: int = 730,
    stop_loss_pct: float = 0.03, take_profit_pct: float = 0.06
) -> str:
    """
    Run a full walk-forward backtest on a strategy definition.
    Returns Sharpe ratio, drawdown, win rate, feature importances,
    and a verdict (promote/iterate/discard).
    Always call this after defining a strategy hypothesis.
    """
    config = StrategyConfig(
        name=name, description=description, features=features,
        entry_logic=entry_logic, exit_logic=exit_logic,
        assets=assets, timeframe=timeframe, lookback_days=lookback_days,
        stop_loss_pct=stop_loss_pct, take_profit_pct=take_profit_pct
    )
    result = run_backtest(config)
    return result.model_dump_json(indent=2)


@tool("get_feature_catalogue")
def get_feature_catalogue() -> str:
    """
    Returns the full list of available features with descriptions.
    Call this before building a strategy to understand what signals
    are available to use.
    """
    features = get_available_features()
    return json.dumps(features, indent=2)


@tool("query_research_history")
def query_research_history(query: str) -> str:
    """
    Search prior research notes and backtest results using semantic search.
    Use this to avoid repeating experiments and to build on prior learnings.
    Query examples: 'momentum strategies that failed', 'features that improved sharpe',
    'best performing regime conditions'
    """
    results = query_knowledge_base(query, top_k=5)
    return json.dumps(results, indent=2)


class SaveResearchNoteInput(BaseModel):
    hypothesis: str
    strategies_tested: list[str]
    features_ruled_in: list[str]
    features_ruled_out: list[str]
    learnings: str
    next_hypothesis: str

@tool("save_research_note", args_schema=SaveResearchNoteInput)
def save_research_note_tool(
    hypothesis: str,
    strategies_tested: list[str],
    features_ruled_in: list[str],
    features_ruled_out: list[str],
    learnings: str,
    next_hypothesis: str
) -> str:
    """
    Save a structured research note to the knowledge base after each cycle.
    ALWAYS call this at the end of every research cycle to persist learnings.
    """
    save_research_note(
        hypothesis=hypothesis,
        strategies_tested=strategies_tested,
        features_ruled_in=features_ruled_in,
        features_ruled_out=features_ruled_out,
        learnings=learnings,
        next_hypothesis=next_hypothesis
    )
    return "Research note saved successfully."


@tool("get_current_market_regime")
def get_current_market_regime() -> str:
    """
    Returns the current market regime classification:
    trending_bull, trending_bear, ranging, high_volatility, low_volatility.
    Use this to contextualise strategy research — some strategies only work
    in specific regimes.
    """
    # TODO: wire to live regime classifier
    return json.dumps({
        "regime": "trending_bull",
        "volatility_percentile": 62,
        "btc_dominance": 54.3,
        "funding_rate_avg": 0.008,
        "confidence": 0.78
    })


@tool("generate_pine_script")
def generate_pine_script(strategy_name: str, backtest_result_json: str) -> str:
    """
    Given a strategy name and its backtest result JSON, generate TradingView
    Pine Script that implements the strategy logic with alerts configured
    for webhook integration.
    """
    # Claude generates this itself — this tool just structures the output
    result = json.loads(backtest_result_json)
    template = f"""
//@version=5
strategy("{strategy_name}", overlay=true, 
         default_qty_type=strategy.percent_of_equity,
         default_qty_value=10)

// Auto-generated by Crypto AI Agent
// Sharpe: {result.get('sharpe_ratio', 'N/A')} | 
// Max DD: {result.get('max_drawdown', 'N/A')}

// === FEATURES ===
// (Claude fills in indicator calculations here)

// === ALERTS FOR WEBHOOK ===
// Configure these alert conditions in TradingView
// pointing to your FastAPI /webhook/tradingview endpoint
"""
    return template


RESEARCH_TOOLS = [
    get_feature_catalogue,
    run_backtest_tool,
    query_research_history,
    save_research_note_tool,
    get_current_market_regime,
    generate_pine_script,
]